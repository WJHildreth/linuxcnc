hpid.ini - height (Z axis) PID control using external offsets (torch height control)

Usage:
  1) Estop OFF  (F1)
  2) Machine ON (F2)
  3) HOME All   (Ctrl-Home)
  4) Run        (R)

The Perturb On/Off buttons control a signal generator that alters the requested torch-volts.  The signal generator's waveform, frequency and amplitude may be set with pyvcp widgets.  The introduced perturbations are useful for tuning the PID settings and may be used when the program is running or paused.

The torch height voltage measurement is simulated with a single-pole low-pass filter.  The frequency response is set by the hal pin: torch-sim.gain The nominal gain setting of 0.2696 emulates a low pass filter with a 50Hz cutoff frequency.  (See the man page for the low pass component)

sim_pin entry boxes are provided for:
  ini.z.max_velocity
  ini.z.max_acceleration
  torch-sim.gain
  zo.pgain
  zo.igain
  zo.dgain



The hpid.ini (height control by pid) sim config:

  configs/sim/axis/external_offsets/hpid.ini

uses the hal component (eoffset_pid.comp) to control torch height by regulating torch voltage.

The torch controller is simulated (torch_sim.hal) by connecting the z axis eoffset (axis.z.eoffset) to a low pass filter and scaling so that a 0.1 inch z offset height corresponds to a 100 volt torch voltage.

To test, the [DISPLAY]OPEN_FILE=hpid_demo.ngc gcode file calls an ngcgui subroutine hpid_sub.ngc.  (An ngcgui tab is also included to set parameters and make gcode files for testing).

The hpid_sub.ngc subroutine accepts inputs to repeat an arbitrary number (#<rpt_ct>) of patterns with fixed width and height and horizontal separation.   Before starting a pattern, a touchoff subroutine is called to start the simulated torch using a spindle (M3S1) command.

The simulation touchoff.ngc subroutine omits probing to the surface and waiting for a torch 'arc-ok' input but a real touchoff routine would likely include these steps.

The eoffset_pid component has three enable inputs (zo.enable-in-a,b,c) that are 'anded' together internally.  The sim config uses the 'a' enable only, the 'b,c' inputs could be used for 'torch-arc-ok' and/or other enabling hal pins.  The disabling of an external offset must return the offset to zero and is not a suitable method for short-term disabling of offset motion.  A hold-request pin can be used to hold the current offset for short time intervals.

When the touchoff subroutine returns, the torch voltage is set by a gcode command (M68), the pattern is traced, and when finished the torch voltage setpoint is returned (M68) to zero

The eoffset_pid component (named 'zo' in the sim config) works to null the error between its command and feedback.  The feedback loop uses:

   1) zo.command --- torch voltage setpoint controlled by gcode (using the hal pin: motion.analog-out-00)

   2) zo.feedback -- from torch_sim.hal using a scaled, lowpass component (torch-height.out)

The main issues with a real hardware implementation will be:

  1) Electrical noise.

     Noise is always problematic for high voltage sparking and requires good design practices for grounding and shielding.  However, excessive filtering of measured torch voltage will compromise stability of the feedback loop.

  2) Tuning the feedback loop.

     The LinuxCNC motion subsystem for z axis control is *inside* the servo loop that regulates torch voltage by control of the z axis external offset.  The input to zo.command is subject to the z axis velocity and acceleration constraints.  The transfer function properties of the motion control affect the stability of the outer voltage control loop.

  3) Height regulation at low velocities.

     At XY corners, velocity reduction causes an increase in torch voltage which is corrected by servo action to decrease the torch heigh.  If this correction is unstable (due to non-linear voltage-height relationship as speed changes for example), the torch can crash to the surface.

     To address this behavior, a hal pin 'zo.current-vel' is provided to observe the current velocity provided by the motion module output on 'motion.current-vel' pin.  Offset correction is suspended when the current-vel is below the threshold set by the 'zo.minimum-vel' hal pin.


TUNING

The pid gain settings are made available on sim_pin gui entry boxes: zo.pgain, zo.igain, zo.dgain.

The ini file settings:

    [AXIS_Z]MAX_ACCELERATION
    [AXIS_Z]MAX_VELOCITY
    [AXIS_Z]OFFSET_AV_RATIO

control the LinuxCNC motion subsystem response.  These should be set based on known limits of the hardware being simulated.  The first two items (ini.z.max_acceleration, ini.z.max_velocity) are made available in sim_pin gui entry boxes for experimentation.

For the sim config, the torch-controller bandwidth is set by the lowpass filter gain torch-height.gain) that is also available as a sim_pin entry box.  The bandwidth limit represents both the frequency response of the z (height) coordinate and the measurement of torch voltage.  Note that very small bandwidths (excessive filtering or slow z response) will make tuning difficult or impossible.  Similarly, if a motor (not a stepper) is used for the z axis, its tuning may affect the tuning of the outer feedback loop that controls the z axis external offset.

To examine/modify servo tuning, start the hpid_demo.ngc gcode program and observe the E:command and E:feedback signals with halscope (automatically started, use 'Roll' mode).  The sequence -- torch-on, cut pattern, torch-off -- repeats, so it is possible to observe the response for different PID gain settings and change them with the sim_pin guis.

With the sim config, some dgain is always required to prevent oscillation,  igain is not useful.

For the sim config, it is convenient to pause the program once the torch is on  and perturb the command input to see the dynamic response when settings are changed.  The convenience of pausing the program is not likely feasible with real hardware since the plasma torch needs to be kept in motion.

The reason for perturbing the zo.command is that the height pid servo is a regulator whose job is to accept a constant voltage command input and regulate the torch-voltage output.  Since both input and output are expected to be constant, it is not always easy to see the loop response.  In the real world, disturbances (height changes like a corrugated material) will require good dynamic response.  Perturbing the command input is an alternate and practical method to oberve and tune the system dynamic response.

The perturbation signal generator enabled with pyvcp panel buttons (On/Off) and associated controls for amplitude, frequency, and waveform.

   sel1 sel0
      0    0  sine wave
      0    1  square wave
      1    0  triangle wave
      1    1  sawtooth wave

A sine wave perturbation is convenient to observe tracking of command and feedback inputs.

The square wave is most commonly used to investigate system overshoot, undershoot, or oscillation for step changes in the command input.

#----------------------------------------------------------
Hardware (non-simulation) implementations

The halfile LIB:basic_sim.tcl is for simulation configurations and should be replaced with an appropriate halfile for real hardware.

Use [HAL]HALFILE=hpid.hal as-is to make most of the required connections.  Some signals are defined that need additional connections which should be made in a separate HALFILE.

  1) The signal E:feedback must be connected to a pin representing measured torch voltage.

  2) The signal E:perturb is available for connection to a perturbation signal (as with the sim configuration)

  3) The signal E:is-off is available for conection elsewhere if needed.

The HALFILES hpid_panel.hal is not required but may be used to enable a perturbation signal generator or as a starting point for a custom pyvcp panel.

The HALFILE torch_sim.hal should be replaced with a halfile that handles all hardware-specific torch controller logic and makes these connections:

   net  E:feedback    <= measure_of_torch-voltage
   sets E:minimum-vel    value_in_units_per_second


The ngc subroutine files touchoff.ngc and hpid_sub.ngc should be adapted for hardware-specific usage.

#----------------------------------------------------------
Alternate PID calculation

The defalt PID calc (zo.fnum=0) uses a simple difference for calculation of the error derivative and will exaggerate noise on  the input feedback.   The noise can be reduced by low pass filtering of the measurement but (see above) too much filtering will destabilize the voltage control servo loop.

An alternative PID calc (zo.fnum=1) computes the error derivative using a backwards difference and limits the gain at high frequencies.  To use this alternative PID calc:

  1) use zo.fnum=1
  2) instead of zo.dgain, use zo.kpt for tuning
  3) use zo.nfilt (values typically between 5 and 20)

Example using sim_pin from the commandline:
$ sim_pin zo.fnum zo.kptd zo.nfilt &

or in the ini file:
[APPLICATIONS]
APP = sim_pin zo.fnum zo.kptd zo.nfilt

